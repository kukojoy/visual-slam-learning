# 第10讲 后端2

# 10.1 滑动窗口滤波和优化

### 10.1.1 实际环境下的BA结构

带有相机位姿和空间点的图优化称为BA，它能够有效地求解大规模的定位与建图问题。然而，在SLAM中，为保持计算的实时性，必须限制后端的计算时间，因此需要控制BA的规模。像SfM中用一周时间重建一个城市地图的算法，可能就不适用于SLAM了。

控制计算规模的做法有很多，比如从连续的视频中抽出一部分作为**关键帧**，仅构造关键帧与路标点之间的BA，非关键帧则只用于定位。但是，随着时间增长，关键帧的数量也会越来越多，使得计算效率下降。因此，仍需要结合其他方法控制BA的规模。

**滑动窗口法**

例如，仅保留离当前时刻最近的$N$个关键帧，将BA固定在一个时间窗口内，离开这个窗口的则被丢弃，称为**滑动窗口法**。当然，取这$N$个关键帧的方法不一定要绝对的时间最近，也可以采用其他策略，满足时间上相对较近，同时空间上也有区分（保证相机即使停止不动，也不会导致算法严重退化）。

**共视图法** 

或者，也可以像ORB-SLAM2一样，定义一种称为“共视图”（与当前帧存在许多共同观测的关键帧所构成的图）的结构。于是，在BA过程中，在共视图里取一些关键帧和路标进行优化。例如，仅优化与当前帧具有20个以上共视路标的关键帧，其余固定不变。当共视图关系能正确构造时，基于共视图的优化也会在更长时间内保持最优。

**小结**

无论是滑动窗口还是共视图，都是为了满足实时计算而做出的折衷。下面从理论和工程的角度，学习这些控制BA规模的方法。

### 10.1.2 滑动窗口法

现在，考虑一个滑动窗口，假设这个窗口内有$N$个关键帧，其位姿表达为：
$$
\boldsymbol{x}_1, \cdots, \boldsymbol{x}_N
$$
在这个滑动窗口中，有$M$个路标点：$\boldsymbol{y}_1, \cdots, \boldsymbol{y}_M$，它们与这$N$个关键帧组成了局部地图。显然，可以用第9讲介绍的BA方法处理这个窗口，即根据投影模型和代价函数构建BA问题，然后边缘化所有路标点来加速求解。在边缘化时，考虑关键帧的位姿，即：
$$
[\boldsymbol{x}_1, \cdots, \boldsymbol{x}_N]^\top \sim N([\boldsymbol{\mu}_1, \cdots, \boldsymbol{\mu}_N]^\top, \boldsymbol{\Sigma})
$$
其中，$\boldsymbol{\mu}_k$为第$k$个关键帧的位姿均值，$\boldsymbol{\Sigma}$为所有关键帧的协方差矩阵。显然，均值就是BA迭代之后的结果，协方差就是对BA的$\boldsymbol{H}$矩阵进行边缘化后的结果，即第9讲中的矩阵$\boldsymbol{S}$。

在滑动窗口中，当窗口结构发生改变，这些状态变量的变化分为两步：

1. 在窗口中新增一个关键帧，以及它观测到的路标点
2. 把窗口中一个旧的关键帧删除，也可能删除它观测到的路标点

**新增一个关键帧和路标点**

在上个时刻，滑动窗口已经建立了$N$个关键帧，我们已经知道它们服从的高斯分布的均值和协方差。此时，来了一个新的关键帧$\boldsymbol{x}_{N + 1}$，那么整个问题中的变量变为$N + 1$个关键帧和更多路标点的集合。只需要按照正常的BA流程处理即可。对所有路标点进行边缘化，得到这$N + 1$个关键帧位姿的高斯分布参数。

**删除一个旧的关键帧**

当考虑删除旧关键帧时，一个理论问题将显现出来。例如要删除旧关键帧$\boldsymbol{x}_1$，但是$\boldsymbol{x}_1$并不是孤立的，它会和其他帧观测到同样的路标。将$\boldsymbol{x}_1$进行边缘化之后将导致整个问题不再稀疏。

假设$\boldsymbol{x}_1$看到了路标点$\boldsymbol{y}_1$至$\boldsymbol{y}_4$，在处理前，BA问题的$\boldsymbol{H}$矩阵应该左图一样。这时，考虑边缘化$\boldsymbol{x}_1$，那么Schur消元会导致右下角的路标点矩阵块不再是非对角矩阵。这个过程称为边缘化中的填入（Fill-in）。

![image-20241127135157529](C:\Users\48423\AppData\Roaming\Typora\typora-user-images\image-20241127135157529.png)

在第9讲中提到，当边缘化路标点时，Fill-in会发生在左上角的位姿块中。不过BA不要求位姿块为对角块结构，此时稀疏BA求解仍然可行。但是，当边缘化关键帧时，将破坏右下角路标点之间的对角块结构，这时BA就无法按照先前的稀疏方式迭代求解。

不过，如果对边缘化的过程进行一些改造，也可以保持滑动窗口BA的稀疏性。例如，在边缘化某个旧的关键帧时，同时边缘化它观测到的路标点。这样，路标点的信息就会转换成剩下那些关键帧之间的共视信息，从而保持右下角部分的对角块结构。在某些SLAM框架中，边缘化策略会更复杂。

**SWF（Sliding Window Filter）中边缘化的直观解释**

在概率上的意义来说，边缘化就是指求条件概率。“边缘化某个关键帧”就是指“保持这个关键帧当前的估计值，并且以这个关键帧为条件，求其他状态变量的条件概率”。所以，当某个关键帧被边缘化之后，它观测到的路标点就会产生一个“这些路标应该在哪里”的先验信息，从而影响其余部分的估计值。如果再边缘化这些路标点，那么它们的观测者将得到一个“观测它们的关键帧应该在哪里”的先验信息。

从数学上看，当边缘化某个关键帧后，整个窗口中的状态变量的描述方式，将从联合分布变成一个条件概率分布：
$$
p(\boldsymbol{x}_1, \dots, \boldsymbol{x}_4, \boldsymbol{y}_1, \dots, \boldsymbol{y}_6) = p(\boldsymbol{x}_2, \dots, \boldsymbol{x}_4, \boldsymbol{y}_1, \dots, \boldsymbol{y}_6 | \boldsymbol{x}_1)p(\boldsymbol{x}_1)
$$
然后舍去被边缘化部分的信息。在变量被边缘化之后，在工程中就不应再使用它。所以，滑动窗口法比较适合VO系统，而不适合大规模建图的系统。

## 10.2 位姿图

### 10.2.1 位姿图的意义

根据前面的讨论，发现特征点在优化问题中占据了绝大部分。实际上，经过若干次观测之后，收敛的特征点位置变化很小，而发散的外点也已经被剔除。因此，可以在优化几次之后就把特征点固定住，只将它们看作位姿估计的约束，而不再实际地优化它们的位置估计。

我们完全可以构建一个只有轨迹的图优化，各位姿节点之间的边，可以由两个关键帧之间通过特征匹配之后得到的运动估计来给定初始值。不同的是，一旦初始估计完成，我们就不再优化那些路标点的位置而只关心所有的相机位姿之间的联系。通过这种方式，我们省去了大量的特征点优化的计算，只保留了关键帧的轨迹，从而构建了所谓的位姿图（Pose Graph）。

在BA中，特征点数量远大于位姿节点。一个关键帧往往关联了数百个关键点，所以当机器人在更大范围的时间和空间中运动时，必须考虑一些解决方式：要么像滑动窗口那样，丢弃一些历史数据。要么像位姿图的做法那样，舍弃对路标点的优化，只保留位姿之间的边。此外，如果有额外测量位姿的传感器，那么位姿图也是一种常见的融合Pose测量的方法。

### 10.2.2 位姿图的优化

具体来说，位姿图优化中的节点表示相机位姿，用$\boldsymbol{T}_1, \dots, \boldsymbol{T}_n$来表示，边则表示两个位姿节点之间的相对运动的估计，该估计可以来自于特征点法或直接法，也可以来自GPS和IMU积分。无论通过哪种手段，假设我们估计了$\boldsymbol{T}_i$和$\boldsymbol{T}_j$之间的一个运动$\Delta \boldsymbol{T}_{ij}$。该运动可以有若干种表达方式，例如：
$$
\Delta \boldsymbol{\xi}_{ij} = \ln(\boldsymbol{T}_i^{-1}\boldsymbol{T}_j)^\vee \quad \mathrm{or} \quad \Delta \boldsymbol{T}_{ij} = \boldsymbol{T}_i^{-1}\boldsymbol{T}_j
$$
按照图优化的思路，实际中该等式并不会精确地成立，因此，可以设立最小二乘误差，然后讨论误差关于优化变量的导数：
$$
\boldsymbol{e}_{ij} = \ln(\Delta \boldsymbol{T}_{ij}^{-1}\boldsymbol{T}_i^{-1}\boldsymbol{T}_j)^\vee
$$
**注意：**$\boldsymbol{e}_{ij}$实际是一个向量，$\Delta \boldsymbol{T}_{ij}$是节点$\boldsymbol{T}_i,\boldsymbol{T}_j$之间的边，理论上，有$\Delta \boldsymbol{T}_{ij}^{-1} \boldsymbol{T}_i^{-1} \boldsymbol{T}_j = \boldsymbol{T}_j^{-1} \boldsymbol{T}_i \boldsymbol{T}_i^{-1} \boldsymbol{T}_j = \boldsymbol{I}$，即$\boldsymbol{e}_{ij}$为零向量，但由于误差的存在，$\boldsymbol{e}_{ij}$并不是零向量。

优化变量有两个：$\boldsymbol{\xi}_i, \boldsymbol{\xi}_j$，按照李代数上的求导法则，可以求出误差关于两个位姿的雅可比矩阵：
$$
\frac{\partial \boldsymbol{e}_{ij}}{\partial \delta\boldsymbol{\xi}_i} = -\mathcal{\boldsymbol{J}}_r^{-1}(\boldsymbol{e}_{ij}) \mathrm{Ad(\boldsymbol{T}_j^{-1})} \\

\frac{\partial \boldsymbol{e}_{ij}}{\partial \delta\boldsymbol{\xi}_j} = \mathcal{\boldsymbol{J}}_r^{-1}(\boldsymbol{e}_{ij}) \mathrm{Ad(\boldsymbol{T}_j^{-1})}
$$
理论上，即使在优化之后，由于每条边给定的观测数据并不一致，误差也不见得近似为零，所以简单地把$\mathcal{\boldsymbol{J}}_r$设置为$\boldsymbol{I}$会有一定的损失。

记$\varepsilon$为所有边的集合，那么总体目标函数为：
$$
\min \frac{1}{2} \sum_{ij \in \varepsilon} \boldsymbol{e}_{ij}^\top\boldsymbol{\Sigma}_{ij}^{-1}\boldsymbol{e}_{ij}
$$
现在，所有的顶点（位姿）和边（位姿间的相对运动）构成了一个图优化，也知道了雅可比矩阵、误差及目标函数，就可以用Ceres、g2o等进行求解了。

## 10.3 实践：位姿图优化

### 10.3.1 g2o原生位姿图

### 10.3.2 李代数上的位姿图优化

### 10.3.3 小结

具体见代码。

